# Задание 3
Реализована улучшенная версия сортировки QuickSort. Отличие от стандартной в том, что пропускаются все равные элементы при сортировке и используется partition через 3 указателя first_equal, greater_or_lower и cur.
* first_equal - указывает на первый элемент равный опорному
* greater_or_lower - указывает на первый элемент больший при сортировке по возрастанию и меньший при сортировке по убыванию
* cur - указывает на текущий проверяемый элемент

## Как использовать?
Для сортировки по возрастанию вызвать quicksort_handler(arr) или quicksort_handler(arr,false), где arr вектор чисел
Для сортировки по убыванию вызвать quicksort_handler(arr, true);

## Обоснование
Данная сортировка быстрее всего сортирует данный ей массив чисел, так как её средняя временная сложность равна O(NlogN), где N - размер массива, и она эффективно работает с памятью.
- Почему NlogN?
Массив рекурсивно делится на 2 подмассива, пока подмассив не будет состоять из 1 элемента. То есть всего возможно около logN делений
После деления по каждому из подмассивов функция проходится и переставляет элементы в зависимости от того больше или меньше они относительно опорного элемента. Пройдясь по двум подмассивам получается временная сложность O(N), где N - размер массива.
Т.к у нас logN делений и при каждом делении надо искать опорный элемент, получается временная сложность O(NlogN)
- Есть другие алгоритмы, которые в среднем выполняют сортировку за O(NlogN) (например HeapSort или MergeSort), почему же именно данная сортировка?
1. Реализованная мной сортировка почти не использует доп память, в отличие от MergeSort или HeapSort, где нужна инициализация временного массива для сохранения перестановок. На инициализацию временного массива (или Heap в случае с HeapSort) как раз таки тратятся лишние такты процессора.
2. За счет того, что все перестановки происходят в исходном массиве, массив кэшируется в процессоре, что позволяет не тратить такты на вызов массива из памяти
3. Как известно, временная сложность QuickSort в худшем случае может быть O(n^2), если постоянно неудачно выбирается опорный элемент. Поэтому, в моей реализации опорный элемент выбирается случайно, чтобы такая ситуация была максимально редко.
4. Может быть такое, что в массиве стоят подряд одинаковые элементы и тратить время нах и проверку не является разумным решением. Поэтому, в реализованной мной функции, пропускаются участки массива, где рядом стоят одинаковые элементы